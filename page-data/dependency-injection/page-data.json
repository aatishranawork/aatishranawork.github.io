{"componentChunkName":"component---src-templates-blog-post-js","path":"/dependency-injection/","result":{"data":{"markdownRemark":{"html":"<h1>Dependency Injection, What, Why and How</h1>\n<p>So you have heard of D.I everywhere. You have tried understanding it, but you need a simple explanation.</p>\n<p>Let's understand Dependency Injection in as little time n effort as possible.</p>\n<p>'<strong>Dependency</strong>' as it's name suggest is just telling us that something can not work unless it has that other thing. Now these 'things' can be a Class or a Method or even a Package.</p>\n<p>The point is if A is dependent on B, A can not work unless B is provided to it.</p>\n<p>Let's see a code example.</p>\n<pre><code class=\"language-java\">import Engine;\r\nclass Car{\r\n\tEngine engine;\r\n\tCar(){\r\n\t\tthis.engine = new Engine();\r\n\t}\r\n\tvoid moveForward(){\r\n\t\tthis.engine.accelerate();\r\n\t\t....\r\n\t}\r\n}\n</code></pre>\n<p>In the above example, in order to use Car's moveForward method, Engine must be created first.</p>\n<br/>\n<p>'<strong>Dependency Injection</strong>' means that our dependencies should be given to us from outside when we need it.</p>\n<p>example</p>\n<pre><code class=\"language-java\">import Engine;\r\nclass Car{\r\n\tEngine engine;\r\n\tCar(Engine engine){\r\n\t\tthis.engine = engine;\r\n\t}\r\n\tvoid moveForward(){\r\n\t\tthis.engine.accelerate();\r\n\t\t....\r\n\t}\r\n}\n</code></pre>\n<p>Unlike the first example, in this example rather than creating class Engine's instance our self, we are given an instance through the  constructor.</p>\n<h3>That's it</h3>\n<p>In essence, the concept is that simple, like Hollywood Principle</p>\n<blockquote>\n<p><em>Don't call us, we'll call you</em></p>\n<p><em>Don't call around for your dependencies, we'll give them to you whenever you need them</em></p>\n</blockquote>\n<p><br/><br/><br/></p>\n<h3>Wanna dive deep?</h3>\n<p>so what is the point of doing this? why can't we simply create instances of our dependencies?</p>\n<p>there are many reasons but the biggest one is</p>\n<p><strong>Loose Coupling</strong></p>\n<p><em>A software which is loosely coupled is considered a good software, because it is reusable,\r\ntestable and extensible.</em></p>\n<br/>\n<p>So how does D.I make loose coupling.</p>\n<p><strong>If we inject our dependencies, we can easily change what we are injecting. daaah!</strong></p>\n<p>So now we can easily create our classes and later decide if they are suppose to be used together.</p>\n<p>let's see another example</p>\n<pre><code class=\"language-java\">import Engine;\r\nclass Car{\r\n\tEngine engine;\r\n\tCar(Engine engine){\r\n\t\tthis.engine = engine;\r\n\t}\r\n\tvoid moveForward(){\r\n\t\tthis.engine.accelerate();\r\n\t\t....\r\n\t}\r\n}\n</code></pre>\n<pre><code class=\"language-java\">import Engine;\r\nclass Truck{\r\n\tEngine engine;\r\n\tTruck(Engine engine){\r\n\t\tthis.engine = engine;\r\n\t}\r\n\tvoid moveForward(){\r\n\t\tthis.engine.accelerate();\r\n\t\t....\r\n\t}\r\n}\r\n\n</code></pre>\n<p>In the above example, we are reusing our Engine class for both Car and Truck. We could have very easily created new instances of the engine inside our constructor, but imagine if object creation code of Engine class was changed.</p>\n<p>from this:</p>\n<pre><code class=\"language-java\">Car(){\r\n\tthis.engine = new Engine();\r\n}\n</code></pre>\n<p>to this:</p>\n<pre><code class=\"language-java\">Car(){\r\n\tthis.engine = new Engine(turboCharge, nitrousOxide);\r\n}\n</code></pre>\n<p>Not only do we have to change our code in Car and Truck class, but anywhere else where Engine class is used. We now also have to create and manage these small objects</p>\n<ul>\n<li>turboCharge</li>\n<li>nitrousOxide</li>\n</ul>\n<p><em>where will they be created?</em></p>\n<p><em>should they be private fields of Car?</em></p>\n<p><em>what if they themselves need objects while creation?</em></p>\n<br/>\n<p>A better approach is to let Car class be responsible only for its own functionality rather than the responsibility of creating an Engine.</p>\n<p>Injecting would also help us test our Car class</p>\n<pre><code class=\"language-java\">Car(Engine fakeEngine){\r\n\tthis.engine = fakeEngine;\r\n}\n</code></pre>\n<pre><code class=\"language-java\">car.setPosition(0, 0);\r\ncar.moveForward();\r\nassertEquals(10, car.getPositionX());\n</code></pre>\n<p>we don't need a real Engine to test our Car class, we can easily pass a fake engine and write test cases for our Car class's methods.</p>\n<br/>\n<h4>Adding Abstraction</h4>\n<p>We can go one step further by using abstract types instead of concrete types and make our classes more extensible.</p>\n<p>let's say instead of a concrete class Engine, we have an abstract Engine</p>\n<pre><code class=\"language-java\">interface Engine{\r\n\tvoid turnOn();\r\n\tvoid turnOff();\r\n\t...\r\n}\n</code></pre>\n<p>And some of its concrete implementation</p>\n<pre><code class=\"language-java\">class PetrolEngine implements Engine{\r\n\tvoid turnOn(){\r\n\t\tthis.useSparkPlug();\r\n\t\t...\r\n\t}\r\n\tvoid turnOff(){\r\n\t\t...\r\n\t}\r\n}\n</code></pre>\n<pre><code class=\"language-java\">class DieselEngine implements Engine{\r\n\tvoid turnOn(){\r\n\t\tthis.useFuelInjector();\r\n\t\t...\r\n\t}\r\n\tvoid turnOff(){\r\n\t\t...\r\n\t}\r\n}\n</code></pre>\n<p>Then we can use our abstract engine in our Car class</p>\n<pre><code class=\"language-java\">import Engine;\r\nclass Car{\r\n\tEngine engine;\r\n\tCar(Engine engine){\r\n\t\tthis.engine = engine;\r\n\t}\r\n\tvoid moveForward(){\r\n\t\tthis.engine.accelerate();\r\n\t\t....\r\n\t}\r\n}\n</code></pre>\n<p>But which real implementation of the engine will be used in Car, will be decided when we create our Car and run our program</p>\n<pre><code class=\"language-java\">class App{\r\n\tpublic static void main(String[] args){\r\n\t\tCar carOne = new Car(new PetolEngine());\r\n\t\tcarOne.moveForward();\r\n\t\t\r\n\t\tCar carTwo = new Car(new DieselEngine());\r\n\t\tcarTwo.moveForward();\r\n\t}\r\n}\n</code></pre>\n<p>we can do this in Truck class and all other classes which uses Engine.\r\nIn future, if we create a new type of engine \"SolarEngine\" we can easily swap it without worrying about changes in any of our Vehicle classes.</p>\n<br/>\n<h2>Conclusion</h2>\n<p><strong>What is Dependency Injection</strong></p>\n<ul>\n<li>Don't call around for your dependencies, we'll give them to you whenever you need them</li>\n</ul>\n<p><strong>Why use Dependency Injection</strong></p>\n<ul>\n<li>To write loosely coupled code</li>\n</ul>\n<p><strong>How to use Dependency Injection</strong></p>\n<ul>\n<li>Pass dependencies through constructor, setter methods or directly to public fields.</li>\n</ul>\n<p><br/><br/></p>\n<h2>P.S.</h2>\n<p>With dependency injection our implementation code is a lot clean and easy, however, we have polluted our calling code</p>\n<pre><code class=\"language-java\">class App{\r\n\tpublic static void main(String[] args){\r\n\t\tNitrousOxide nitro = new NitrousOxide();\r\n\t\tTurboCharge turboCharge = new TurboCharge();\r\n\t\tEngine engine = new SuperEngine(turboCharge, nitro);\r\n\t\tCar car = new Car(engine);\r\n\t\tcar.moveForward();\r\n\t}\r\n}\n</code></pre>\n<p>This has created a lot of boilerplate code, which doesn't do anything but waste a lot of developer's time. This boilerplate also has to be created in right order otherwise it won't work. This can easily become very complex and hard to maintain if we are working on a large project.</p>\n<p>To avoid this, we can use a D.I library, which we will discuss in future posts.</p>","frontmatter":{"title":"Dependency Injection","date":"2020-07-15T00:00:00.000Z"}}},"pageContext":{"slug":"/dependency-injection/"}},"staticQueryHashes":["712709547"],"slicesMap":{}}