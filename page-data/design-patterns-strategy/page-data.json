{"componentChunkName":"component---src-templates-blog-post-js","path":"/design-patterns-strategy/","result":{"data":{"markdownRemark":{"html":"<h1>Design Patterns - Strategy</h1>\n<p>In the strategy pattern, the method of a class is defined as a separate interface and concrete implementation of that interface is used depending on our need. This allows better decoupling between the method and the class that uses the method.</p>\n<p>If you don't know what Polymorphism is I would encourage you to go through that first.</p>\n<br>\n<h3>Done?</h3>\n<p>I will assume you know what polymorphism is from now on.</p>\n<p>So in polymorphism or more specifically (subtype/inclusion) polymorphism our compiler allow us to write a method that takes a class T in its argument, but will also work correctly if passed a subclass of T</p>\n<p>example:</p>\n<pre><code class=\"language-java\">public class Application{\r\n  public static void main(String[] args){\r\n    describeAnimal(new Lion());\r\n    describeAnimal(new Duck());\r\n  }\r\n  \r\n  public static void describeAnimal(Animal animal){\r\n    animal.walk();\r\n    animal.eat();\r\n    animal.fly();\r\n  }\r\n}\n</code></pre>\n<p>The method describeAnimal takes 1 argument of type Animal but it will work correctly even when passed an argument of Animal's subtype (Lion, Duck, etc).</p>\n<pre><code class=\"language-java\">public interface Animal{\r\n  void walk();\r\n  void eat();\r\n  void fly();\r\n}\n</code></pre>\n<pre><code class=\"language-java\">public class Lion implements Animal{\r\n \r\n  @Override\r\n  public void walk(){\r\n    // code of animal walking on 4 legs\r\n  }\r\n  \r\n  @Override\r\n  public void eat(){\r\n    // code of animal eating and processing meat\r\n  }\r\n\r\n  @Override\r\n  public void fly(){\r\n    // this animal can't fly, handle that\r\n  }\r\n}\n</code></pre>\n<pre><code class=\"language-java\">public class Duck implements Animal{\r\n \r\n  @Override\r\n  public void walk(){\r\n    // code of animal walking on 2 legs\r\n  }\r\n  \r\n  @Override\r\n  public void eat(){\r\n    // code of animal eating bread crumbs\r\n  }\r\n\r\n  @Override\r\n  public void fly(){\r\n    // code of animal flying at low altitude\r\n  }\r\n}\n</code></pre>\n<p>Now this polymorphic behavior of animal looks good but in large applications where we add more and more types of animals, because they have different types of behaviors(strategies) on how to walk, eat, fly and so on, things can go out of hands very quickly.</p>\n<p>Currently, these 2 types have completely different strategies of all 3 methods but if we add more types of animals, many of them would have all or some similarities.</p>\n<p>example:</p>\n<pre><code class=\"language-java\">public class Monkey implements Animal{\r\n \r\n  @Override\r\n  public void walk(){\r\n    // code of animal walking on 2 legs\r\n  }\r\n  \r\n  @Override\r\n  public void eat(){\r\n    // code of animal eating banana\r\n  }\r\n\r\n  @Override\r\n  public void fly(){\r\n    // can not fly\r\n  }\r\n}\n</code></pre>\n<p>now monkey walks on 2 legs just like duck however it doesn't fly like the lion and at the same time, it is also vegetarian like the duck.</p>\n<p>we can add more animals, like Dragon which can eat meat, fly high and walk on 2 legs.\r\nor add Chimpanzee which eats a banana, cannot fly and walk on 2 legs exactly same as Monkey.</p>\n<p>Moreover, as we add more behavior to our animal class(swim, makeSound, etc), there are going be more combinations of behaviors.</p>\n<p>Naive programmers might start copy-pasting code of similar behavior in each type, or worse they might create a superclass with common behavior and start extending from them until they get stuck with maximum single inheritance feature of almost every major object-oriented language (Java, c# etc)</p>\n<p>example</p>\n<p>creating base classes for reuse</p>\n<pre><code class=\"language-java\">public class WalkingOnTwoFeet{\r\n  void walk(){\r\n    // code of animal walking on 2 legs\r\n  }\r\n}\r\npublic class Vegetarian{\r\n  void eat(){\r\n    // code of animal eating veg food\r\n  }\r\n}\r\npublic class NonFlyer{\r\n  void fly(){\r\n    // empty\r\n  }\r\n}\n</code></pre>\n<p>not able to use them</p>\n<pre><code class=\"language-java\">public class Monkey extends WalkingOnTwoFeet implements Animal{\r\n \r\n  @Override\r\n  public void walk(){\r\n    super.walk();\r\n  }\r\n  \r\n  @Override\r\n  public void eat(){\r\n    // can not extend Vegetarian\r\n  }\r\n\r\n  @Override\r\n  public void fly(){\r\n    // can not extend NonFlyer\r\n  }\r\n}\n</code></pre>\n<br>\n<h3>In strategy pattern, we take our behavior(walking, eating, flying) and define them in separate concrete classes and use them via an abstract interface.</h3>\n<p>First, we create interfaces for each of our behavior</p>\n<pre><code class=\"language-java\">public interface WalkingStrategy{\r\n  void walk();\r\n}\r\npublic interface EatingStrategy{\r\n  void eat();\r\n}\r\npublic interface FlyingStrategy{\r\n  void fly();\r\n}\n</code></pre>\n<p>And then their concrete implementations depending on our needs.</p>\n<br>\n<p>For walking:</p>\n<pre><code class=\"language-java\">public class WalkingOnTwoFeet implements WalkingStrategy{\r\n  void walk(){\r\n    // code of animal walking on 2 legs\r\n  }\r\n}\n</code></pre>\n<pre><code class=\"language-java\">public class WalkingOnFourFeet implements WalkingStrategy{\r\n  void walk(){\r\n    // code of animal walking on 4 legs\r\n  }\r\n}\n</code></pre>\n<br>\n<p>For eating:</p>\n<pre><code class=\"language-java\">public class Vegetarian implements EatingStrategy{\r\n  void eat(){\r\n    // code of animal eating veg food\r\n  }\r\n}\n</code></pre>\n<pre><code class=\"language-java\">public class NonVegetarian implements EatingStrategy{\r\n  void eat(){\r\n    // code of animal eating non veg food\r\n  }\r\n}\n</code></pre>\n<br>\n<p>For flying:</p>\n<pre><code class=\"language-java\">public class NonFlyer implements FlyingStrategy{\r\n  void fly(){\r\n    // empty\r\n  }\r\n}\n</code></pre>\n<pre><code class=\"language-java\">public class LowFlyer implements FlyingStrategy{\r\n  void fly(){\r\n    // code of animal flying at low altitude\r\n  }\r\n}\n</code></pre>\n<pre><code class=\"language-java\">public class HighFlyer implements FlyingStrategy{\r\n  void fly(){\r\n    // code of animal flying at high altitude\r\n  }\r\n}\n</code></pre>\n<br>\n<p>So now our animals would use these strategies depending on its type</p>\n<pre><code class=\"language-java\">import WalkingOnFourFeet;\r\nimport NonVegetarian;\r\nimport NonFlyer;\r\n\r\npublic class Lion implements Animal{\r\n \r\n  @Override\r\n  public void walk(){\r\n    new WalkingOnFourFeet().walk();\r\n  }\r\n  \r\n  @Override\r\n  public void eat(){\r\n    new NonVegetarian().eat();\r\n  }\r\n\r\n  @Override\r\n  public void fly(){\r\n    new NonFlyer().fly();\r\n  }\r\n}\n</code></pre>\n<p>now this example of Lion is <strong>very bad</strong> and must not be used in production code(or anywhere for that matter).</p>\n<p>As you can see the concrete implementations of each of our strategies are created inside Lion class, so we have to import them. Which means every time we want to use a new strategy for lion we have to change code inside Lion then recompile and redeploy Lion along with our new strategy.</p>\n<p><strong>Instead, we should use our abstract interfaces of strategies and inject concrete implementations through constructor injection.</strong></p>\n<p>If you don't know what Dependency Injection is and it's benefits go through it from <a href=\"/dependency-injection\">here</a></p>\n<br>\n<p>So a better version of Lion would be</p>\n<pre><code class=\"language-java\">import WalkingStrategy;\r\nimport EatingStrategy;\r\nimport FlyingStrategy;\r\n\r\npublic class Lion implements Animal{\r\n \r\n  private WalkingStrategy walkingStrategy;\r\n  private EatingStrategy eatingStrategy;\r\n  private FlyingStrategy flyingStrategy;\r\n  \r\n  public Lion(WalkingStrategy walkingStrategy,\r\n              EatingStrategy eatingStrategy,\r\n              FlyingStrategy flyingStrategy){\r\n    this.walkingStrategy = walkingStrategy;\r\n    this.eatingStrategy = eatingStrategy;\r\n    this.flyingStrategy = flyingStrategy;\r\n  }\r\n  \r\n  @Override\r\n  public void walk(){\r\n    this.walkingStrategy.walk();\r\n  }\r\n  \r\n  @Override\r\n  public void eat(){\r\n    this.eatingStrategy.eat();\r\n  }\r\n\r\n  @Override\r\n  public void fly(){\r\n    this.flyingStrategy.fly();\r\n  }\r\n}\n</code></pre>\n<p>And when we need to create a Lion</p>\n<pre><code class=\"language-java\">public class Application{\r\n  public static void main(String[] args){\r\n    WalkingStrategy fourFeet = new WalkingOnFourFeet();\r\n    EatingStrategy nonVeg = new NonVegetarian();\r\n    FlyingStrategy noFly = new NonFlyer();\r\n    \r\n    Animal lion = new Lion(fourFeet, nonVeg, noFly);\r\n  }\r\n}\n</code></pre>\n<br>\n<p>Same for other types of animals</p>\n<pre><code class=\"language-java\">import WalkingStrategy;\r\nimport EatingStrategy;\r\nimport FlyingStrategy;\r\n\r\npublic class Duck implements Animal{\r\n \r\n  private WalkingStrategy walkingStrategy;\r\n  private EatingStrategy eatingStrategy;\r\n  private FlyingStrategy flyingStrategy;\r\n  \r\n  public Duck(WalkingStrategy walkingStrategy,\r\n              EatingStrategy eatingStrategy,\r\n              FlyingStrategy flyingStrategy){\r\n    this.walkingStrategy = walkingStrategy;\r\n    this.eatingStrategy = eatingStrategy;\r\n    this.flyingStrategy = flyingStrategy;\r\n  }\r\n  \r\n  @Override\r\n  public void walk(){\r\n    this.walkingStrategy.walk();\r\n  }\r\n  \r\n  @Override\r\n  public void eat(){\r\n    this.eatingStrategy.eat();\r\n  }\r\n\r\n  @Override\r\n  public void fly(){\r\n    this.flyingStrategy.fly();\r\n  }\r\n}\n</code></pre>\n<pre><code class=\"language-java\">public class Application{\r\n  public static void main(String[] args){\r\n    WalkingStrategy twoFeet = new WalkingOnTwoFeet();\r\n    EatingStrategy veg = new Vegetarian();\r\n    FlyingStrategy lowFly = new LowFlyer();\r\n    \r\n    Animal duck = new Duck(twoFeet, veg, lowFly);\r\n  }\r\n}\n</code></pre>\n<h4>That is it. That's the strategy pattern</h4>\n<h4>Conclusion</h4>\n<p>In the strategy pattern, the method(<em>walk, eat, fly</em>) of a class(<em>Animal</em>) is defined as a separate interface(<em>EatingStrategy</em>) and concrete implementation(<em>Vegetarian</em>) of that interface is used depending on our need.</p>\n<br>\n<h4>Ps.</h4>\n<p>In cases where there are no other methods and properties for Lion except for these strategies which are being injected, we don't even need a separate class \"Lion\" to represent it, we can just create an AnimalFactory class and it can have a method which is responsible for creating the right Lion type for us using just the Animal interface.</p>\n<p>That's <strong>Simple Factory</strong>, a topic we can discuss <a href=\"http://aatishrana.com/blog/design-patterns-factory\">here</a>.</p>","frontmatter":{"title":"Design Pattern Strategy","date":"2020-07-15T00:00:00.000Z"}}},"pageContext":{"slug":"/design-patterns-strategy/"}},"staticQueryHashes":["712709547"],"slicesMap":{}}