<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="generator" content="Gatsby 5.8.1"/><style data-href="/styles.a12bcf6191efd6182d5f.css" data-identity="gatsby-global-css">nav{min-width:180px;padding:10px}.Navbar-module--blog_parent--1464e{margin-top:50px}body{color:#000;font-family:Georgia,serif;height:100vh;margin:0;overflow:hidden;padding:0;width:100vw}code{background-color:#f1f1f1;border-radius:4px;display:block;font-family:monospace;padding:10px}h1,h2,h3,h4,h5,h6{color:#505050}.Layout-module--layout_outer--ac406{display:flex;flex-direction:column;height:100vh;margin:0;overflow-y:auto;padding:0}.Layout-module--layout_inner--60f26{display:flex;margin:0;padding:0;width:100%}.Layout-module--content--9bbaf{margin-left:auto;margin-right:auto;width:60%}.Layout-module--navbar2--1ae06{background-color:#fff;display:none;height:100%;left:-300px;position:absolute;top:0;width:300px}@media screen and (max-width:768px){.Layout-module--content--9bbaf{margin-right:0;width:70%}}@media screen and (max-width:480px){.Layout-module--navbar--9a68e{display:none}.Layout-module--navbar2--1ae06{display:flex;flex-direction:column}.Layout-module--content--9bbaf{margin:0;width:100%}}.Header-module--header--923a3{display:flex;padding:10px}.Header-module--menu--2487e{display:none}.Header-module--headercontent--5a238{display:flex}.Header-module--aatish--554a5{background-image:url(/static/aatish-f3443295fbaae08b8755fe96406979a7.jpeg);background-size:contain;border-radius:60px;height:100px;margin-left:auto;margin-right:auto;width:100px}@media screen and (max-width:480px){.Header-module--menu--2487e{display:inline}.Header-module--headercontent--5a238{justify-content:center;margin:auto}}.BlogPost-module--blog--44e9c{padding:15px 15px 30px}</style></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><div class="Layout-module--layout_outer--ac406"><div class="Header-module--header--923a3"><div class="Header-module--menu--2487e" role="button" tabindex="0">â˜°</div><div class="Header-module--headercontent--5a238"><a style="text-decoration:none" href="/"><div class="Header-module--aatish--554a5"></div><h2 style="text-align:center;margin-bottom:0">Aatish Rana</h2></a></div></div><div class="Layout-module--layout_inner--60f26"><div class="Layout-module--navbar--9a68e"><nav><div class="Navbar-module--blog_parent--1464e"><article><a style="text-decoration:none" href="/data-structure-array/"><h5>Data Structure Array</h5></a></article><article><a style="text-decoration:none" href="/data-structure-graph/"><h5>Data Structure Graph</h5></a></article><article><a style="text-decoration:none" href="/data-structure-map/"><h5>Data Structure Map</h5></a></article><article><a style="text-decoration:none" href="/data-structure-list/"><h5>Data Structure List</h5></a></article><article><a style="text-decoration:none" href="/data-structure-tree/"><h5>Data Structure Tree</h5></a></article><article><a style="text-decoration:none" href="/design-patterns-behaviour/"><h5>Design Pattern Behaviour</h5></a></article><article><a aria-current="page" style="text-decoration:none" class="" href="/dependency-injection/"><h5>Dependency Injection</h5></a></article><article><a style="text-decoration:none" href="/design-patterns-creation/"><h5>Design Pattern Creation</h5></a></article><article><a style="text-decoration:none" href="/design-patterns-strategy/"><h5>Design Pattern Strategy</h5></a></article><article><a style="text-decoration:none" href="/design-patterns-fp/"><h5>Design Pattern In FP</h5></a></article><article><a style="text-decoration:none" href="/design-patterns-structure/"><h5>Design Pattern Structure</h5></a></article></div></nav></div><div class="Layout-module--navbar2--1ae06" style="left:-300px;box-shadow:none"><p style="margin:10px 10px 0px 0px;text-align:right" role="button" tabindex="0">X</p><nav><div class="Navbar-module--blog_parent--1464e"><article><a style="text-decoration:none" href="/data-structure-array/"><h5>Data Structure Array</h5></a></article><article><a style="text-decoration:none" href="/data-structure-graph/"><h5>Data Structure Graph</h5></a></article><article><a style="text-decoration:none" href="/data-structure-map/"><h5>Data Structure Map</h5></a></article><article><a style="text-decoration:none" href="/data-structure-list/"><h5>Data Structure List</h5></a></article><article><a style="text-decoration:none" href="/data-structure-tree/"><h5>Data Structure Tree</h5></a></article><article><a style="text-decoration:none" href="/design-patterns-behaviour/"><h5>Design Pattern Behaviour</h5></a></article><article><a aria-current="page" style="text-decoration:none" class="" href="/dependency-injection/"><h5>Dependency Injection</h5></a></article><article><a style="text-decoration:none" href="/design-patterns-creation/"><h5>Design Pattern Creation</h5></a></article><article><a style="text-decoration:none" href="/design-patterns-strategy/"><h5>Design Pattern Strategy</h5></a></article><article><a style="text-decoration:none" href="/design-patterns-fp/"><h5>Design Pattern In FP</h5></a></article><article><a style="text-decoration:none" href="/design-patterns-structure/"><h5>Design Pattern Structure</h5></a></article></div></nav></div><div class="Layout-module--content--9bbaf"><div class="BlogPost-module--blog--44e9c"><div><h1>Dependency Injection, What, Why and How</h1>
<p>So you have heard of D.I everywhere. You have tried understanding it, but you need a simple explanation.</p>
<p>Let's understand Dependency Injection in as little time n effort as possible.</p>
<p>'<strong>Dependency</strong>' as it's name suggest is just telling us that something can not work unless it has that other thing. Now these 'things' can be a Class or a Method or even a Package.</p>
<p>The point is if A is dependent on B, A can not work unless B is provided to it.</p>
<p>Let's see a code example.</p>
<pre><code class="language-java">import Engine;
class Car{
	Engine engine;
	Car(){
		this.engine = new Engine();
	}
	void moveForward(){
		this.engine.accelerate();
		....
	}
}
</code></pre>
<p>In the above example, in order to use Car's moveForward method, Engine must be created first.</p>
<br/>
<p>'<strong>Dependency Injection</strong>' means that our dependencies should be given to us from outside when we need it.</p>
<p>example</p>
<pre><code class="language-java">import Engine;
class Car{
	Engine engine;
	Car(Engine engine){
		this.engine = engine;
	}
	void moveForward(){
		this.engine.accelerate();
		....
	}
}
</code></pre>
<p>Unlike the first example, in this example rather than creating class Engine's instance our self, we are given an instance through the  constructor.</p>
<h3>That's it</h3>
<p>In essence, the concept is that simple, like Hollywood Principle</p>
<blockquote>
<p><em>Don't call us, we'll call you</em></p>
<p><em>Don't call around for your dependencies, we'll give them to you whenever you need them</em></p>
</blockquote>
<p><br/><br/><br/></p>
<h3>Wanna dive deep?</h3>
<p>so what is the point of doing this? why can't we simply create instances of our dependencies?</p>
<p>there are many reasons but the biggest one is</p>
<p><strong>Loose Coupling</strong></p>
<p><em>A software which is loosely coupled is considered a good software, because it is reusable,
testable and extensible.</em></p>
<br/>
<p>So how does D.I make loose coupling.</p>
<p><strong>If we inject our dependencies, we can easily change what we are injecting. daaah!</strong></p>
<p>So now we can easily create our classes and later decide if they are suppose to be used together.</p>
<p>let's see another example</p>
<pre><code class="language-java">import Engine;
class Car{
	Engine engine;
	Car(Engine engine){
		this.engine = engine;
	}
	void moveForward(){
		this.engine.accelerate();
		....
	}
}
</code></pre>
<pre><code class="language-java">import Engine;
class Truck{
	Engine engine;
	Truck(Engine engine){
		this.engine = engine;
	}
	void moveForward(){
		this.engine.accelerate();
		....
	}
}

</code></pre>
<p>In the above example, we are reusing our Engine class for both Car and Truck. We could have very easily created new instances of the engine inside our constructor, but imagine if object creation code of Engine class was changed.</p>
<p>from this:</p>
<pre><code class="language-java">Car(){
	this.engine = new Engine();
}
</code></pre>
<p>to this:</p>
<pre><code class="language-java">Car(){
	this.engine = new Engine(turboCharge, nitrousOxide);
}
</code></pre>
<p>Not only do we have to change our code in Car and Truck class, but anywhere else where Engine class is used. We now also have to create and manage these small objects</p>
<ul>
<li>turboCharge</li>
<li>nitrousOxide</li>
</ul>
<p><em>where will they be created?</em></p>
<p><em>should they be private fields of Car?</em></p>
<p><em>what if they themselves need objects while creation?</em></p>
<br/>
<p>A better approach is to let Car class be responsible only for its own functionality rather than the responsibility of creating an Engine.</p>
<p>Injecting would also help us test our Car class</p>
<pre><code class="language-java">Car(Engine fakeEngine){
	this.engine = fakeEngine;
}
</code></pre>
<pre><code class="language-java">car.setPosition(0, 0);
car.moveForward();
assertEquals(10, car.getPositionX());
</code></pre>
<p>we don't need a real Engine to test our Car class, we can easily pass a fake engine and write test cases for our Car class's methods.</p>
<br/>
<h4>Adding Abstraction</h4>
<p>We can go one step further by using abstract types instead of concrete types and make our classes more extensible.</p>
<p>let's say instead of a concrete class Engine, we have an abstract Engine</p>
<pre><code class="language-java">interface Engine{
	void turnOn();
	void turnOff();
	...
}
</code></pre>
<p>And some of its concrete implementation</p>
<pre><code class="language-java">class PetrolEngine implements Engine{
	void turnOn(){
		this.useSparkPlug();
		...
	}
	void turnOff(){
		...
	}
}
</code></pre>
<pre><code class="language-java">class DieselEngine implements Engine{
	void turnOn(){
		this.useFuelInjector();
		...
	}
	void turnOff(){
		...
	}
}
</code></pre>
<p>Then we can use our abstract engine in our Car class</p>
<pre><code class="language-java">import Engine;
class Car{
	Engine engine;
	Car(Engine engine){
		this.engine = engine;
	}
	void moveForward(){
		this.engine.accelerate();
		....
	}
}
</code></pre>
<p>But which real implementation of the engine will be used in Car, will be decided when we create our Car and run our program</p>
<pre><code class="language-java">class App{
	public static void main(String[] args){
		Car carOne = new Car(new PetolEngine());
		carOne.moveForward();
		
		Car carTwo = new Car(new DieselEngine());
		carTwo.moveForward();
	}
}
</code></pre>
<p>we can do this in Truck class and all other classes which uses Engine.
In future, if we create a new type of engine "SolarEngine" we can easily swap it without worrying about changes in any of our Vehicle classes.</p>
<br/>
<h2>Conclusion</h2>
<p><strong>What is Dependency Injection</strong></p>
<ul>
<li>Don't call around for your dependencies, we'll give them to you whenever you need them</li>
</ul>
<p><strong>Why use Dependency Injection</strong></p>
<ul>
<li>To write loosely coupled code</li>
</ul>
<p><strong>How to use Dependency Injection</strong></p>
<ul>
<li>Pass dependencies through constructor, setter methods or directly to public fields.</li>
</ul>
<p><br/><br/></p>
<h2>P.S.</h2>
<p>With dependency injection our implementation code is a lot clean and easy, however, we have polluted our calling code</p>
<pre><code class="language-java">class App{
	public static void main(String[] args){
		NitrousOxide nitro = new NitrousOxide();
		TurboCharge turboCharge = new TurboCharge();
		Engine engine = new SuperEngine(turboCharge, nitro);
		Car car = new Car(engine);
		car.moveForward();
	}
}
</code></pre>
<p>This has created a lot of boilerplate code, which doesn't do anything but waste a lot of developer's time. This boilerplate also has to be created in right order otherwise it won't work. This can easily become very complex and hard to maintain if we are working on a large project.</p>
<p>To avoid this, we can use a D.I library, which we will discuss in future posts.</p></div></div></div></div></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/dependency-injection/";/*]]>*/</script><!-- slice-start id="_gatsby-scripts-1" -->
          <script
            id="gatsby-chunk-mapping"
          >
            window.___chunkMapping="{\"app\":[\"/app-946cb9c7f4d0d2351e90.js\"],\"component---src-pages-index-js\":[\"/component---src-pages-index-js-c1c00c577b8a33b13079.js\"],\"component---src-templates-blog-post-js\":[\"/component---src-templates-blog-post-js-f90a59558bd0122b821d.js\"]}";
          </script>
        <script>window.___webpackCompilationHash="af6d6d600f2d52493964";</script><script src="/webpack-runtime-c3755894492d6210d357.js" async></script><script src="/framework-ece53a4dfa3f421a9587.js" async></script><script src="/app-946cb9c7f4d0d2351e90.js" async></script><!-- slice-end id="_gatsby-scripts-1" --></body></html>